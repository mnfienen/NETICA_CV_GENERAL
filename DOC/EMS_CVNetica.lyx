#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass elsarticle
\begin_preamble
\usepackage{lineno}
\renewcommand\[{\begin{equation}}
\renewcommand\]{\end{equation}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing double
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CVNetica--A cross-validation package driving Netica with Python 
\end_layout

\begin_layout Author
Michael N.
 Fienen
\end_layout

\begin_layout Address
US Geological Survey, Wisconsin Water Science Center, 8505 Research Way,
 Middleton WI 53562 USA
\end_layout

\begin_layout Email
mnfienen@usgs.gov
\end_layout

\begin_layout Author
Nathaniel G.
 Plant
\end_layout

\begin_layout Address
US Geological Survey, St.
 Petersburg Coastal and Marine Science Center, 600 Fourth Street South,
 St.
 Petersburg, Florida, 33701, USA.
\end_layout

\begin_layout Email
nplant@usgs.gov
\end_layout

\begin_layout Abstract
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset

Bayesian networks (BNs) are powerful tools for probabilistically simulating
 natural systems and emulating process models.
 Cross validation is an important technique to avoid overfitting that can
 result from overly complex BNs such that model predictions have true skill.
 Formal cross-validation procedures to evaluate relative performance in
 prediction outside of calibration data has been discussed in various studies
 but rarely implemented.
 The lack of widespread cross-validation is due in part to a lack of software
 tools designed to work with available BN packages.
 CVNetica is an open-source package written in Python that extends the Netica
 software package to include cross-validation and a framework to read, rebuild,
 and learn BNs from data in a Python scripting environment.
 Optimal BN complexity can be identified through exploration of numbers
 of bins, nodes, and edges making up a BN using predictive skill as a metric
 of performance.
 The insights gained from cross-validation and implications on predictive
 versus descriptive skill are illustrated with two applications: a data-driven
 oceanographic application in which wave height predictions are made from
 time series data learned from nearby buoys and weather stations; and a
 model-emulation application in which the source of water to groundwater
 wells is evaluated using a BN trained to the results of a large, regional
 groundwater process model.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over the past 20 years or so, the use of Bayesian Networks 
\begin_inset CommandInset citation
LatexCommand citep
before "BN; "
key "JensenNielsen2001"

\end_inset

 has increased greatly, in large measure due to the availability of commercial
 software packages such as Netica 
\begin_inset CommandInset citation
LatexCommand citep
key "Netica"

\end_inset

 and Hugin 
\begin_inset CommandInset citation
LatexCommand citep
key "Hugin"

\end_inset

 among many others.
 Applications in water resources have included groundwater management 
\begin_inset CommandInset citation
LatexCommand citep
key "mdso2007,Molina2010,Molina2013"

\end_inset

, and model emulation 
\begin_inset CommandInset citation
LatexCommand citep
key "plant2011a,plant2011b,FienenBNWRR"

\end_inset

.
 This builds on a history of applications in national security, economics,
 and ecology.
\end_layout

\begin_layout Standard
An important topic that is discussed less in the literature than general
 applications of BNs is the need for formal validation of performance 
\begin_inset CommandInset citation
LatexCommand citep
key "Chen2012,Marcot2012"

\end_inset

.
 Some validation metrics are calculable by the commercial software packages,
 but substantial gaps in capabilities remain.
 Fortunately, at least in the case of Netica, an application programming
 interface (API) exists with versions in multiple programming languages.
 To create a toolbox of performance metrics, we used Python 
\begin_inset CommandInset citation
LatexCommand citep
key "python"

\end_inset

 with the Netica C APIs.
 These APIs expose most of Netica's functionality, through functions, to
 external programming.
 Among the languages available, C was chosen because the ultimate goal was
 to interface with Python 2.7.6 
\begin_inset CommandInset citation
LatexCommand citep
key "python"

\end_inset

 and Numpy 1.9 
\begin_inset CommandInset citation
LatexCommand citep
key "scipy"

\end_inset

.
 We discuss the technical challenges associated with running C APIs using
 Python and describe the toolbox of validation metrics included in this
 work.
\end_layout

\begin_layout Standard
Building on techniques introduced by 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

, we developed tools addressing two fundamental questions of Bayesian network
 performance: how does predictive performance compare with calibration quality?;
 and how does the complexity of the underlying network impact predictive
 and calibration performance? Cross-validation is used to answer both questions,
 and the number of bins per node is used as a metric of complexity to answer
 the second.
 These specific questions are evaluated in this work but the framework is
 presented to allow for other validation metrics and techniques beyond those
 presented here.
\end_layout

\begin_layout Standard
Model 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Bayesian Networks
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A Bayesian network (BN) is a directed acyclic graph 
\begin_inset CommandInset citation
LatexCommand citep
key "Korb2004"

\end_inset

, composed of nodes and edges.
 Nodes represent states of parameters or outcomes and can be Boolean or
 discrete bins.
 Continuous values of parameters must be discretized into bins.
 Edges form the connections between nodes and represent a correlated connection
 between the properties represented by the nodes.
 The entire catalog of these correlations make up conditional probability
 tables (CPTs).
 Nodes can be thought of as input (e.g.
 forcing) nodes and output (e.g.
 response) nodes, although this distinction is not a sharp one as the correlatio
ns learned by the BN are ambivalent with respect to direction.
 Nodes can also be intermediate.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
khgfjhgf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of a BN created and visualized using Netica is presented in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/net_Example.pdf
	lyxscale 35
	scale 35

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:exampleBN"

\end_inset

Example of a Netica BN showing input (outlined in a red box) and output
 (outlined in a blue box) nodes, edges (black lines) and, in this case,
 a single intermediate node (recharge).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calculations are made using the BN based on conditional probabilities using
 Bayes’ Theorem 
\begin_inset Formula 
\begin{equation}
p\left(F_{i}|O_{j}\right)=\frac{p\left(O_{j}|F_{i}\right)p\left(F_{i}\right)}{p\left(O_{j}\right)}\label{eq:bayesthm}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $p\left(F_{i}|O_{j}\right)$
\end_inset

 is the posterior (updated) probability of a forecast 
\begin_inset Formula $\left(F_{i}\right)$
\end_inset

 given (conditional on) a set of observations 
\begin_inset Formula $\left(O_{j}\right)$
\end_inset

; 
\begin_inset Formula $p\left(O_{j}|F_{i}\right)$
\end_inset

 is the likelihood function, 
\begin_inset Formula $p\left(F_{i}\right)$
\end_inset

 is the prior probability of the forecast, and 
\begin_inset Formula $p\left(O_{j}\right)$
\end_inset

 is a normalizing constant.
 The posterior probability reflects an updating that is achieved by considering
 the entire chain of conditional probabilities of all bins connected to
 the node representing 
\begin_inset Formula $F_{i}$
\end_inset

.
 The likelihood function represents the probability that the observations
 
\begin_inset Formula $\left(O_{j}\right)$
\end_inset

 would be observed given that the forecast was perfectly known.
 This is a metric of the ability of the BN to function as a forecasting
 device and imperfections in such forecasts are a function of epistemic
 uncertainty.
 Epistemic uncertainty includes uncertainty due to model imperfection, data
 errors, and other sources.
 The prior probability of the forecast, 
\begin_inset Formula $p\left(F_{i}\right)$
\end_inset

, is the probability of a forecast without the benefit of the observations
 and the BN (or a process model or other experiment).
 
\begin_inset Formula $p\left(F_{i}\right)$
\end_inset

 may be calculated by using expert knowledge, or may be assumed relatively
 uninformative to make the entire process as objective as practical (similar
 to an ignorance prior 
\begin_inset CommandInset citation
LatexCommand citep
key "jaynesBook"

\end_inset

).
 A common prior often used in BNs is the division of a node into bins of
 equal probability.
 This is the approach generally followed in this work, resulting in bins
 of equal probability or ‘‘belief’’ although it is not exactly an ignorance
 prior because the probability mass in each bin may differ due to variable
 bin widths.
 It is possible to evaluate the contribution to all uncertainty values calculate
d by the BN by expressing the uncertainty in the prior probabilities.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

, the horizontal bars correspond to relative probabilities associated with
 bins outlined by the numbers listed to the left of them.
 These bars form a histogram and are commonly referred to as ``belief bars.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Once a system is cast in a BN, new observations of system state are applied
 and propagated through the BN using Bayes’ theorem such that all forecasts
 made in the model are contingent upon the specific observations of system
 state.
 In other words, each forecast is associated with a specific configuration
 of observations of system state.
 Observations are indicated by selecting a bin and forcing the probability
 of a value in the node to be 100%.
 When this operation is performed, the Bayesian update propagates in each
 direction among nodes that are d-connected 
\begin_inset CommandInset citation
LatexCommand citep
key "JensenNielsen2001"

\end_inset

, updating the probabilities regardless of causal direction.
 In this way, correlations are expressed as well as causal responses.
 By selecting a suite of observations of state, the BN functions like a
 transfer function by providing an estimate of the forecast of interest
 and associated uncertainty.
 
\end_layout

\begin_layout Standard
A key piece of a priori information is the establishment of edges connecting
 the nodes.
 Edges should reflect a cascade of causality grounded in an understanding
 of the underlying process being modeled.
 If multiple processes from different models are to be linked, the selection
 of edge relationships defines the linkage.
 While machine learning can be used to teach a BN which parameters are connected
 to each other and to outputs, we adopt the more common method in which
 expert system understanding is used to specify these connections through
 the identification of nodes and edges.
 In this way, the BN honors the physical conditions known by the modeler,
 incorporated as soft knowledge.
 
\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

, arrows on the edges indicate the direction of causal dependence.
 When all nodes are d-connected, the direction of the edge arrows serve
 no purpose.
 However, in the context of d-separation, the direction of causality has
 important ramifications on the propagation of uncertainty from observations
 to forecasts.
\end_layout

\begin_layout Standard
When computational conditions and problem size permit, a conditional probability
 table (CPT) can be created that directly enumerates the conditional probabiliti
es of all nodes in the BN.
 This becomes impractical rapidly, however, because the size of the CPT
 scales on the order of 
\begin_inset Formula $n\times d^{k+1}$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the number of nodes, 
\begin_inset Formula $d$
\end_inset

 is the number of bins, and 
\begin_inset Formula $k$
\end_inset

 is the number of parents for a node.
 In the case where full enumeration is impractical due to this rapid increase
 in computational expense with complexity, an iterative expectation-maximization
 (EM) algorithm is used 
\begin_inset CommandInset citation
LatexCommand citep
key "Dempster1977"

\end_inset

 to calculate approximate probabilities and maximum-likelihood values for
 the BN without full enumeration of the CPT.
 The EM algorithm iterates between estimating the maximum log likelihood
 of the function and finding the set of parameters resulting in that maximum
 log likelihood.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
CVNetica Code
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CVNetica is a Python module that performs cross-validation and calculates
 other performance metrics on BNs created with the Netica software package.
 Netica is a commercial package with more power than open-source alternatives.
 However, CVNetica is open-source and freely available.
 The APIs for Netica are described in 
\begin_inset CommandInset citation
LatexCommand citep
key "NeticaAPI"

\end_inset

.
 Pyth
\end_layout

\begin_layout Standard
The core functionality of CVNetica is based around the concept of using
 cross-validation metrics to asses the quality of predictions made by a
 BN.
 
\end_layout

\begin_layout Itemize
k-fold
\end_layout

\begin_deeper
\begin_layout Itemize
what metrics (focus on skill for this paper, include ref.
 to WRR and general CV lit.)
\end_layout

\end_deeper
\begin_layout Itemize
predictive vs.
 descriptive
\end_layout

\begin_layout Itemize
the role and nature of model complexity
\end_layout

\begin_deeper
\begin_layout Itemize
bins bins bins
\end_layout

\begin_layout Itemize
edges? nodes? 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Details about program structure
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What did we actually implement?
\end_layout

\begin_layout Itemize
CV_driver.py -- the main entry point and options
\end_layout

\begin_deeper
\begin_layout Itemize
config XML
\end_layout

\end_deeper
\begin_layout Itemize
pyNeticaTools --> these are the general hooks into the DLL and could be
 a starting point for non-CV related projects
\end_layout

\begin_layout Itemize
PostProcessing
\end_layout

\begin_deeper
\begin_layout Itemize
what's included in CV_driver.py?
\end_layout

\begin_layout Itemize
what's outside of that?
\end_layout

\begin_deeper
\begin_layout Itemize
including plotting
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Working with Ctypes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Netica software provides APIs for accessing and using the functions
 within it.
 Several versions of these APIs are available as precompiled libraries.
 To interface with Python, the C programming language APIs can be interfaced
 with using the 
\family typewriter
ctypes
\family default
 which is built-in to Python 2.7+.
 The 
\family typewriter
ctypes
\family default
 module enables the use of functions from a dynamic library of C code (a
 DLL on Windows) in the Python environment.
 In addition to making the functions accessible, some translation of variables
 is required--for example, C often refers to data using pointers whereas
 Python does not explicitly do so.
 To pass a Python array to a C function, then, the variable must be passed
 by reference (this is not explicitly done in Python) as a pointer.
 Similarly, C functions often return pointers to memory space of the resulting
 arrays so 
\family typewriter
ctypes
\family default
 must be used to read the correct amount of data from memory to populate
 an array for further use in Python.
 
\end_layout

\begin_layout Standard
CVNetica provides Python functions wrapped around Netica C functions and
 helper functions to translate data to and from the Python environment.
 In the remainder of this section, the main aspects of interfacing with
 the Netica APIs are discussed in general terms.
 These examples use code snippets from the CVNetica codebase.
 Further documentation about 
\family typewriter
ctypes
\family default
 is available from the official documentation (http://docs.python.org/2/library/ct
ypes.html).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Accessing the DLL
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first task when accessing the Netica DLL is to make the functions available
 to Python by assigning the DLL to an object.
 Note that the filename is not in quotes, nor is the 
\family typewriter
.dll
\family default
 extension required.
 The 
\family typewriter
ctypes
\family default
 module is imported as 
\family typewriter
ct
\family default
 so in future code descriptions, 
\family typewriter
ct.<>
\family default
 implies a method or property from 
\family typewriter
ctypes
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import ctypes as ct
\end_layout

\begin_layout Plain Layout

self.n = ct.windll.Netica
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this, 
\family typewriter
self.n
\family default
 is an object with all of the Netica API functions available.
 To call a function from the DLL, the function name is dereferenced from
 self.n and in CVNetica, a wrapper function is created as an interface to
 the Netica function.
 In the following example, the Netica function to be called is 
\family typewriter
EnterNodeValue_bn
\family default
.
 This function takes two arguments as defined by Netica: 
\family typewriter
void EnterNodeValue_bn (node_bn* node, double value)
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "NeticaAPI"

\end_inset

.
 The two arguments are of the custom C type defined by Netica as 
\family typewriter
node_bn* node
\family default
 and a double-precision float 
\family typewriter
double value
\family default
.
 A wrapper around this function must then make type conversions as appropriate.
 The CVNetica variable 
\family typewriter
cnode
\family default
 was returned by a Netica function, so it is already of the type required
 (a pointer).
 However, the CVNetica variable 
\family typewriter
cval
\family default
 is a Python float and must be converted to a C double using a 
\family typewriter
ctypes
\family default
 conversion.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def EnterNodeValue(self,cnode,cval):
\end_layout

\begin_layout Plain Layout

	self.n.EnterNodeValue_bn(cnode,ct.c_double(cval))         
\end_layout

\begin_layout Plain Layout

	self.chkerr()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
chkerr
\family default
 method polls the Netica DLL for current error status and, if an error is
 encountered, kills CVNetica and displays the error from Netica to standard
 output.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exchanging information with the Netica DLL
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The functions in Netica can accept a variety of argument types.
 The easiest type is a pointer to an object returned by another Netica function.
 In this case, a Python variable represents the pointer--just a memory address--
so no conversion is necessary.
 For single Python floats and ints, the conversions are 
\family typewriter
ct.c_double(cval)
\family default
 and 
\family typewriter
ct.c_int(cval)
\family default
, respectively, where 
\family typewriter
cval
\family default
 is the Python variable.
 
\end_layout

\begin_layout Standard
The most straightforward retrieval of of information from a Netica function
 is when the returned value is a pointer to a Netica object (for example,
 the Netica environment, a node, or a net).
 These values can be assigned to variables in Python and then passed to
 Netica functions without any alteration, as illustrated above.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Example Results
\end_layout

\begin_layout Standard
Here we talk about two applications mostly referencing other papers for
 the description.
\end_layout

\begin_layout Subsection
Data driven ocean waves
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What do we get out of this kind of analysis? Berm example of data driven,
 
\end_layout

\begin_layout Standard
NATHANIEL works here! Track changes on if I work anywhere else!
\end_layout

\begin_layout Standard
styles in drop-down on left of menu
\end_layout

\begin_layout Standard
insert figure as a float/figure and insert a tag as label
\end_layout

\begin_layout Standard
bibTex is the biliography foramt to export and copy into the GW.bib
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Model emulation source of groundwater to wells
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
and LMB example for model emulation.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion and Conclusions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
how does the code work?
\end_layout

\begin_layout Itemize
what did we learn in data-driven areas?
\end_layout

\begin_layout Itemize
what are ramifications for model emulation design?
\end_layout

\begin_layout Itemize
is CV really all that or a waste of time?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
This work was funded by (ASIS and GLAS others depending on which example
 application we use).
 We are deeply grateful to Steven Mascaro for his initial PyNetica.py code
 which he kindly shared as a starting point for this work.
\end_layout

\begin_layout Section
Disclaimer
\end_layout

\begin_layout Standard
Any use of trade, product, or firm names is for descriptive purposes only
 and does not imply endorsement by the U.S.
 Government.
 
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "GW"
options "elsarticle-num-names"

\end_inset


\end_layout

\end_body
\end_document
