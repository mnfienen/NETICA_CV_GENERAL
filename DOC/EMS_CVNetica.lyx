#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass elsarticle
\begin_preamble
\usepackage{lineno}
\renewcommand\[{\begin{equation}}
\renewcommand\]{\end{equation}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing double
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author -74556787 "Michael Fienen" 
\end_header

\begin_body

\begin_layout Title
CVNetica--A cross-validation package driving Netica with Python 
\end_layout

\begin_layout Author
Michael N.
 Fienen
\end_layout

\begin_layout Address
US Geological Survey, Wisconsin Water Science Center, 8505 Research Way,
 Middleton WI 53562 USA
\end_layout

\begin_layout Email
mnfienen@usgs.gov
\end_layout

\begin_layout Author
Nathaniel G.
 Plant
\end_layout

\begin_layout Address
US Geological Survey, St.
 Petersburg Coastal and Marine Science Center, 600 Fourth Street South,
 St.
 Petersburg, Florida, 33701, USA.
\end_layout

\begin_layout Email
nplant@usgs.gov
\end_layout

\begin_layout Abstract
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset

Bayesian networks (BNs) are powerful tools for probabilistically simulating
 natural systems and emulating process models.
 Cross validation is an important technique to avoid overfitting that can
 result from overly complex BNs such that model predictions have true skill.
 Formal cross-validation procedures to evaluate relative performance in
 prediction outside of calibration data has been discussed in various studies
 but rarely implemented.
 The lack of widespread cross-validation is due in part to a lack of software
 tools designed to work with available BN packages.
 CVNetica is an open-source package written in Python that extends the Netica
 software package to include cross-validation and a framework to read, rebuild,
 and learn BNs from data in a Python scripting environment.
 Optimal BN complexity can be identified through exploration of numbers
 of bins, nodes, and edges making up a BN using predictive skill as a metric
 of performance.
 The insights gained from cross-validation and implications on predictive
 versus descriptive skill are illustrated with two applications: a data-driven
 oceanographic application in which wave height predictions are made from
 time series data learned from nearby buoys and weather stations; and a
 model-emulation application in which the source of water to groundwater
 wells is evaluated using a BN trained to the results of a large, regional
 groundwater process model.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Over the past 
\change_deleted -74556787 1396027304
20 years or so
\change_inserted -74556787 1396027306
two decades
\change_unchanged
, the use of Bayesian Networks 
\begin_inset CommandInset citation
LatexCommand citep
before "BN; "
key "JensenNielsen2001"

\end_inset

 has increased greatly, in large measure due to the availability of commercial
 software packages such as Netica 
\begin_inset CommandInset citation
LatexCommand citep
key "Netica"

\end_inset

 and Hugin 
\begin_inset CommandInset citation
LatexCommand citep
key "Hugin"

\end_inset

 among many others.
 Applications in water resources have included groundwater management 
\begin_inset CommandInset citation
LatexCommand citep
key "mdso2007,Molina2010,Molina2013"

\end_inset

, and model emulation 
\begin_inset CommandInset citation
LatexCommand citep
key "plant2011a,plant2011b,FienenBNWRR"

\end_inset

.
 This builds on a history of applications in national security, economics,
 and ecology.
\end_layout

\begin_layout Standard
An important topic that is discussed less in the literature than general
 applications of BNs is the need for formal validation of performance 
\begin_inset CommandInset citation
LatexCommand citep
key "Chen2012,Marcot2012"

\end_inset

.
 Some validation metrics are calculable by the commercial software packages,
 but substantial gaps in capabilities remain.
 Fortunately, at least in the case of Netica, an application programming
 interface (API) exists with versions in multiple programming languages.
 To create a toolbox of performance metrics, we used Python 
\begin_inset CommandInset citation
LatexCommand citep
key "python"

\end_inset

 with the Netica C APIs.
 These APIs expose most of Netica's functionality, through functions, to
 external programming.
 Among the languages available, C was chosen because the ultimate goal was
 to interface with Python 2.7.6 
\begin_inset CommandInset citation
LatexCommand citep
key "python"

\end_inset

 and Numpy 1.8 and Scipy 0.13.2 
\begin_inset CommandInset citation
LatexCommand citep
key "scipy"

\end_inset

.
 We discuss the technical challenges associated with running C APIs using
 Python and describe the toolbox of validation metrics included in this
 work.
\end_layout

\begin_layout Standard
Building on techniques introduced by 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

, we developed tools addressing two fundamental questions of Bayesian network
 performance: how does predictive performance compare with descriptive calibrati
on quality?; and how does the complexity of the underlying network impact
 predictive and descriptive performance? Cross-validation is used to answer
 both questions, and the number of bins per node is used as a metric of
 complexity to answer the second.
 These specific questions are evaluated in this work but the framework is
 presented to allow for other validation metrics and techniques beyond those
 presented here.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Bayesian Networks
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A Bayesian network (BN) is a directed acyclic graph 
\begin_inset CommandInset citation
LatexCommand citep
key "Korb2004"

\end_inset

, composed of nodes and edges.
 Nodes represent states of parameters or outcomes and can be Boolean or
 discrete bins.
 Continuous values of parameters must be discretized into bins.
 Edges form the connections between nodes and represent a correlated connection
 between the properties represented by the nodes.
 The entire catalog of these correlations make up conditional probability
 tables (CPTs).
 Nodes can be thought of as input (e.g.
 forcing) nodes and output (e.g.
 response) nodes, although this distinction is not a sharp one as the correlatio
ns learned by the BN are ambivalent with respect to direction.
 Nodes can also be intermediate.
\end_layout

\begin_layout Standard
An example of a BN created and visualized using Netica is presented in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/net_Example.pdf
	lyxscale 35
	scale 35

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:exampleBN"

\end_inset

Example of a Netica BN showing input (outlined in a red box) and output
 (outlined in a blue box) nodes, edges (black lines) and, in this case,
 a single intermediate node (recharge).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calculations are made using the BN based on conditional probabilities using
 Bayes’ Theorem 
\begin_inset Formula 
\begin{equation}
p\left(F_{i}|O_{j}\right)=\frac{p\left(O_{j}|F_{i}\right)p\left(F_{i}\right)}{p\left(O_{j}\right)}\label{eq:bayesthm}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $p\left(F_{i}|O_{j}\right)$
\end_inset

 is the posterior (updated) probability of a forecast 
\begin_inset Formula $\left(F_{i}\right)$
\end_inset

 given (conditional on) a set of observations 
\begin_inset Formula $\left(O_{j}\right)$
\end_inset

; 
\begin_inset Formula $p\left(O_{j}|F_{i}\right)$
\end_inset

 is the likelihood function, 
\begin_inset Formula $p\left(F_{i}\right)$
\end_inset

 is the prior probability of the forecast, and 
\begin_inset Formula $p\left(O_{j}\right)$
\end_inset

 is a normalizing constant.
 The posterior probability reflects an updating that is achieved by considering
 the entire chain of conditional probabilities of all bins connected to
 the node representing 
\begin_inset Formula $F_{i}$
\end_inset

.
 The likelihood function represents the probability that the observations
 
\begin_inset Formula $\left(O_{j}\right)$
\end_inset

 would be observed given that the forecast was perfectly known.
 This is a metric of the ability of the BN to function as a forecasting
 device and imperfections in such forecasts are a function of epistemic
 uncertainty.
 Epistemic uncertainty includes uncertainty due to model imperfection, data
 errors, and other sources.
 The prior probability of the forecast, 
\begin_inset Formula $p\left(F_{i}\right)$
\end_inset

, is the probability of a forecast without the benefit of the observations
 and the BN (or a process model or other experiment).
 
\begin_inset Formula $p\left(F_{i}\right)$
\end_inset

 may be calculated by using expert knowledge, or may be assumed relatively
 uninformative to make the entire process as objective as practical (similar
 to an ignorance prior 
\begin_inset CommandInset citation
LatexCommand citep
key "jaynesBook"

\end_inset

).
 A common prior often used in BNs is the division of a node into bins of
 equal probability.
 This is the approach generally followed in this work, resulting in bins
 of equal probability or ‘‘belief’’ although it is not exactly an ignorance
 prior because the probability mass in each bin may differ due to variable
 bin widths.
 It is possible to evaluate the contribution to all uncertainty values calculate
d by the BN by expressing the uncertainty in the prior probabilities.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

, the horizontal bars correspond to relative probabilities associated with
 bins outlined by the numbers listed to the left of them.
 These bars form a histogram and are commonly referred to as ``belief bars.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Once a system is cast in a BN, new observations of system state are applied
 and propagated through the BN using Bayes’ theorem such that all forecasts
 made in the model are contingent upon the specific observations of system
 state.
 In other words, each forecast is associated with a specific configuration
\change_inserted -74556787 1396027332
s
\change_deleted -74556787 1396027335
 of observations
\change_unchanged
 of system state.
 Observations are indicated by selecting a bin and forcing the probability
 of a value in the node to be 100%.
 When this operation is performed, the Bayesian update propagates in each
 direction among nodes that are d-connected 
\begin_inset CommandInset citation
LatexCommand citep
key "JensenNielsen2001"

\end_inset

, updating the probabilities regardless of causal direction.
 In this way, correlations are expressed as well as causal responses.
 By selecting a suite of observations of state, the BN functions like a
 transfer function by providing an estimate of the forecast of interest
 and associated uncertainty.
 
\end_layout

\begin_layout Standard
A key piece of a priori information is the establishment of edges connecting
 the nodes.
 Edges should reflect a cascade of causality grounded in an understanding
 of the underlying process being modeled.
 If multiple processes from different models are to be linked, the selection
 of edge relationships defines the linkage.
 While machine learning can be used to teach a BN which parameters are connected
 to each other and to outputs, we adopt 
\change_deleted -74556787 1396027348
the more common method
\change_inserted -74556787 1396027352
a Bayesian approach
\change_unchanged
 in which expert system understanding is used to specify these connections
 through the identification of nodes and edges.
 In this way, the BN honors the physical conditions known by the modeler,
 incorporated as soft knowledge.
 
\end_layout

\begin_layout Standard
In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

, arrows on the edges indicate the direction of causal dependence.
 When all nodes are d-connected, the direction of the edge arrows serve
 no purpose.
 However, in the context of d-separation, the direction of causality has
 important ramifications on the propagation of uncertainty from observations
 to forecasts.
\end_layout

\begin_layout Standard
When computational conditions and problem size permit, a conditional probability
 table (CPT) can be created that directly enumerates the conditional probabiliti
es of all nodes in the BN.
 This becomes impractical rapidly, however, because the size of the CPT
 scales on the order of 
\begin_inset Formula $n\times d^{k+1}$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the number of nodes, 
\begin_inset Formula $d$
\end_inset

 is the number of bins, and 
\begin_inset Formula $k$
\end_inset

 is the number of parents for a node.
 In the case where full enumeration is impractical due to this rapid increase
 in computational expense with complexity, an iterative expectation-maximization
 (EM) algorithm is used 
\begin_inset CommandInset citation
LatexCommand citep
key "Dempster1977"

\end_inset

 to calculate approximate probabilities and maximum-likelihood values for
 the BN without full enumeration of the CPT.
 The EM algorithm iterates between estimating the maximum log likelihood
 of the function and finding the set of parameters resulting in that maximum
 log likelihood.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Cross validation tool
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
CVNetica is a Python module that performs cross-validation and calculates
 other performance metrics on BNs created with the Netica software package.
 Netica is a commercial package with more power than open-source alternatives.
 However, CVNetica is open-source and freely available.
 The APIs for Netica are described in 
\begin_inset CommandInset citation
LatexCommand citep
key "NeticaAPI"

\end_inset

 and are provided as a dynamic linked library (DLL) for Windows.
 Static libraries are also available for Macintosh and *nix platforms, but
 to use them with Python, dynamic interface wrappers would be necessary
 in addition to the Python function wrappers written in CVNetica.
 
\end_layout

\begin_layout Standard
The core functionality of CVNetica is based around the concept of using
 cross-validation 
\begin_inset CommandInset citation
LatexCommand citep
key "StatLearning2009,Marcot2012,FienenBNWRR"

\end_inset

 metrics to asses the quality of predictions made by a BN.
 In 
\begin_inset Formula $k$
\end_inset

-fold cross validation used in this work, the calibration dataset is, randomly
 without replacement, divided into 
\begin_inset Formula $k$
\end_inset

 fold
\change_inserted -74556787 1396027374
s
\change_unchanged
 or partitions where 
\begin_inset Formula $k$
\end_inset

 typically is between 2 and 10.
 For each fold, the BN is trained using the dataset without the data in
 the fold, then the BN is used to make predictions on the left-out data.
 In this way, performance of the BN is evaluated on data not used in calibration
 to simulate how performance in true future prediction.
 Several performance metrics can be used for this purpose, as discussed
 in 
\begin_inset CommandInset citation
LatexCommand citet
key "Netica"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "plant2011a"

\end_inset

, and 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

.
 In this work, we will focus on skill
\begin_inset Formula 
\begin{equation}
sk=\left[1-\frac{\sigma_{e}^{2}}{\sigma_{o}^{2}}\right]\label{skill}
\end{equation}

\end_inset

where 
\begin_inset Formula $\sigma_{e}^{2}$
\end_inset

 is the mean squared error between observations and BN predictions, and
 
\begin_inset Formula $\sigma_{o}^{2}$
\end_inset

 is the variance of the observations 
\begin_inset CommandInset citation
LatexCommand citep
key "Gutierrez2011,plant2011a,Weigend1994"

\end_inset

.
 Skill is evaluated by comparing BN predictions to observations with a value
 of unity indicating perfect correspondence and a value of zero indicating
 substantial discrepancy between BN predictions and observations.
\change_inserted -74556787 1396027397

\end_layout

\begin_layout Standard

\change_inserted -74556787 1396027631
CVNetica also reports log loss, error rate, experience, quadratic loss,
 mutual information (entropy), variance reduction (sensitivity) all of which
 are described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Netica,NeticaAPI"

\end_inset

.
 Expected values are reported either as mean or most likely (ML).
 For ML values, the value corresponding to the center of a bin is reported.
 For mean values, the value is interpolated to a discrete value within the
 response bin.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -74556787 1396027639
NATHANIEL - did I get this right?
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
By evaluating skill over both the calibration data sets and prediction data
 sets, the value of a BN as a descriptive or predictive tool can be evaluated.
 As BN complexity- increases, so does 
\begin_inset Formula $sk$
\end_inset

 and with sufficient complexity, 
\begin_inset Formula $sk$
\end_inset

 over the calibration data converges on unity (perfection).
 However, greater descriptive value in a BN comes at a cost in predictive
 value.
 This is the classic condition of overfitting as cast in the context of
 information theory by 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

.
\end_layout

\begin_layout Standard
One way to systematically evaluate BN complexity is to systematically adjust
 the number of bins for each node with more bins meaning a greater level
 of complexity.
 CVNetica has the capability to make this type of analysis efficient by
 allowing the user to specify an original BN and a configuration of bin
\change_inserted -74556787 1396027691
s
\change_unchanged
 for each node.
 CVNetica then builds a new BN with the requested number of bins and assigning
 equiprobable prior distributions for each bin.
 In 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

 the number of bins was assumed the same for each node but in CVNetica the
 number of bins in each node can be varied independently to allow for exploratio
n of various assumptions of complexity.
 The user can also establish scenarios manually varying the number and nature
 of edges connecting nodes and even the number of nodes themselves.
 A group of these scenarios is defined by CVNetica as a ``set.
\begin_inset Quotes erd
\end_inset

 Each set can be evaluated as a batch and then plots generated of performance
 metrics across the sets.
\end_layout

\begin_layout Standard
NATHANIEL - do we need an appendix with all other metrics identified? I
 DON'T KNOW HOW MUCH DETAIL WE NEED TO INCLUDE ON ALL THAT.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Details about program structure
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two levels at which CVNetica performs.
 At the highest level, a script in 
\begin_inset Formula $\mathtt{CV\_driver.py}$
\end_inset

 performs the cross validation protocol described in this manuscript.
 This script is driven by an XML-based configuration file and should general
\change_inserted -74556787 1396027714
ly
\change_unchanged
 require minimal editing, save for identifying the configuration file to
 use in the 
\begin_inset Formula $\mathtt{parfile}$
\end_inset

 variable name.
 At a lower level, 
\begin_inset Formula $\mathtt{pythonNeticaTools.py}$
\end_inset

 provides the 
\begin_inset Formula $\mathtt{pyneticaTools}$
\end_inset

 class that interacts with the Netica DLL directly with wrappers around
 many essential Netica functions.
 Examples of how these methods work are discussed in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Accessing-the-DLL"

\end_inset

.
 At an intermediate level, 
\begin_inset Formula $\mathtt{pythonNetica.py}$
\end_inset

 provides the 
\begin_inset Formula $\mathtt{pynetica}$
\end_inset

 class that combines several Netica functions for tasks such as starting
 a Netica environment, rebinning nodes, and other intermediate level tasks.
\end_layout

\begin_layout Subsubsection
Cross Validation Driver
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\mathtt{CV\_driver.py}$
\end_inset

 script drives a cross-validation exercise over the number of folks specified
 in the XML based configuration file (Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XMLinput"

\end_inset

).
 If no rebinning is requested (
\begin_inset Formula $\mathtt{<rebin\_flag>False</rebin\_flag>}$
\end_inset

), the BN specified in the 
\begin_inset Formula $\mathtt{baseNET}$
\end_inset

 element is used for analysis along with the casefile identified by the
 
\begin_inset Formula $\mathtt{baseCAS}$
\end_inset

 element and metrics of performance.
 If the 
\begin_inset Formula $\mathtt{rebin\_flag}$
\end_inset

 element is True, then the nodes from the BN identified in the 
\begin_inset Formula $\mathtt{originalNET}$
\end_inset

 element are rediscretized using the information on rebinning provided at
 the end of the input file.
 For each node listed, if 
\begin_inset Formula $\mathtt{numbins>0}$
\end_inset

 the node is discretized into bins 
\begin_inset Formula $\mathtt{numbins}$
\end_inset

 bins of equal probability.
 In the special case where 
\begin_inset Formula $\mathtt{numbins=0}$
\end_inset

, the node is not rediscretized but it is used either as input or response
 as described by the 
\begin_inset Formula $\mathtt{input}$
\end_inset

 and 
\begin_inset Formula $\mathtt{response}$
\end_inset

 elements above.
 This special case allows for other discretization strategies (such as threshold
s) to be implemented for nodes that are to be treated as input or response
 nodes but without equiprobable discretization.
 Nodes that are not identified as either input or response should not have
 
\begin_inset Formula $\mathtt{node}$
\end_inset

 elements provided and are unaltered by CVNetica in the analysis.
\end_layout

\begin_layout Standard
If the 
\begin_inset Formula $\mathtt{CVflag}$
\end_inset

 element is False, only a single run using all the data in the 
\begin_inset Formula $\mathtt{baseCAS}$
\end_inset

 file and the BN identified in the 
\begin_inset Formula $\mathtt{baseNET}$
\end_inset

 is performed and metrics are calculated.
 The predictions for each configuration of input are recorded in a compressed
 Python pickle file (NATHANIEL - SHOULD WE SPIT OUT A MEASURED AND MODELED
 TEXT FILE AS WELL YOU THINK? A COLUMN FOR EACH INPUT, AND EACH OUTPUT GETS
 TWO COLUMNS -- ONE MEAS ONE MOD?).
\end_layout

\begin_layout Standard
If the 
\begin_inset Formula $\mathtt{CVflag}$
\end_inset

 element is True, then k-fold cross validation is performed using the number
 of folds indicated in the 
\begin_inset Formula $\mathtt{numfolds}$
\end_inset

 element.
 For each fold, 
\begin_inset Formula $\frac{n}{k}$
\end_inset

 (where 
\begin_inset Formula $n$
\end_inset

 is the total number of data points and 
\begin_inset Formula $k$
\end_inset

 is the number of folds) data points are separated from the rest of the
 data points to be left out of the calibration.
 The BN is then retrained on the 
\begin_inset Formula $n-\frac{n}{k}$
\end_inset

 retained data and metrics of performance are calculated for both the left
 out data (referred to as ``validation
\begin_inset Quotes erd
\end_inset

) and the training data (referred to as ``calibration
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Itemize
CV_driver.py -- the main entry point and options
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/imputfileexample.pdf

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:XMLinput"

\end_inset

Example XML configuration file for defining problem parameters.
 Blue text identifies syntax of element names, green text indicates comments
 in the file, and bold black text indicates element values.
 In the special case of the 
\begin_inset Formula $\mathtt{node}$
\end_inset

 element, an attribute (numbins) is indicated in red text.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pyNeticaTools --> these are the general hooks into the DLL and could be
 a starting point for non-CV related projects
\end_layout

\begin_layout Itemize
PostProcessing
\end_layout

\begin_deeper
\begin_layout Itemize
what's included in CV_driver.py?
\end_layout

\begin_layout Itemize
what's outside of that?
\end_layout

\begin_deeper
\begin_layout Itemize
including plotting
\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Working with Ctypes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Netica software provides APIs for accessing and using the functions
 within it.
 Several versions of these APIs are available as precompiled libraries.
 To interface with Python, the C programming language APIs can be interfaced
 using the 
\family typewriter
ctypes
\family default
 
\change_inserted -74556787 1396027734
module 
\change_unchanged
which is built-in to Python 2.7+.
 The 
\family typewriter
ctypes
\family default
 module enables the use of functions from a dynamic library of C code (a
 DLL on Windows) in the Python environment.
 In addition to making the functions accessible, some translation of variables
 is required--for example, C often refers to data using pointers whereas
 Python does not explicitly do so.
 To pass a Python array to a C function, then, the variable must be passed
 by reference (this is not explicitly done in Python) as a pointer.
 Similarly, C functions often return pointers to memory space of the resulting
 arrays so 
\family typewriter
ctypes
\family default
 must be used to read the correct amount of data from memory to populate
 an array for further use in Python.
 
\end_layout

\begin_layout Standard
CVNetica provides Python functions wrapped around Netica C functions and
 helper functions to translate data to and from the Python environment.
 In the remainder of this section, the main aspects of interfacing with
 the Netica APIs are discussed in general terms.
 These examples use code snippets from the CVNetica codebase.
 Further documentation about 
\family typewriter
ctypes
\family default
 is available from the official documentation (http://docs.python.org/2/library/ct
ypes.html).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Accessing-the-DLL"

\end_inset

Accessing the DLL
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first task when accessing the Netica DLL is to make the functions available
 to Python by assigning the DLL to an object.
 Note that the filename is not in quotes, nor is the 
\family typewriter
.dll
\family default
 extension required.
 The 
\family typewriter
ctypes
\family default
 module is imported as 
\family typewriter
ct
\family default
 so in future code descriptions, 
\family typewriter
ct.<>
\family default
 implies a method or property from 
\family typewriter
ctypes
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import ctypes as ct
\end_layout

\begin_layout Plain Layout

self.n = ct.windll.Netica
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this, 
\family typewriter
self.n
\family default
 is an object with all of the Netica API functions available.
 To call a function from the DLL, the function name is dereferenced from
 
\family typewriter
self.n
\family default
 and in CVNetica, a wrapper function is created as an interface to the Netica
 function.
 In the following example, the Netica function to be called is 
\family typewriter
EnterNodeValue_bn
\family default
.
 This function takes two arguments as defined by Netica: 
\family typewriter
void EnterNodeValue_bn (node_bn* node, double value)
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "NeticaAPI"

\end_inset

.
 The two arguments are of the custom C type defined by Netica as 
\family typewriter
node_bn* node
\family default
 and a double-precision float 
\family typewriter
double value
\family default
.
 A wrapper around this function must then make type conversions as appropriate.
 The CVNetica variable 
\family typewriter
cnode
\family default
 was returned by a Netica function, so it is already of the type required
 (a pointer).
 However, the CVNetica variable 
\family typewriter
cval
\family default
 is a Python float and must be converted to a C double using a 
\family typewriter
ctypes
\family default
 conversion.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def EnterNodeValue(self,cnode,cval):
\end_layout

\begin_layout Plain Layout

	self.n.EnterNodeValue_bn(cnode,ct.c_double(cval))         
\end_layout

\begin_layout Plain Layout

	self.chkerr()
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
chkerr
\family default
 method polls the Netica DLL for current error status and, if an error is
 encountered, kills CVNetica and displays the error from Netica to standard
 output.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Exchanging information with the Netica DLL
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The functions in Netica can accept a variety of argument types.
 In the 
\begin_inset Formula $\mathtt{pyneticaTools}$
\end_inset

 class, methods that function as wrappers around Netica functions are written.
 The names are the same as the Netica functions with the 
\begin_inset Formula $\mathtt{\_bn}$
\end_inset

, 
\begin_inset Formula $\mathtt{\_cs}$
\end_inset

, and 
\begin_inset Formula $\mathtt{\_ns}$
\end_inset

 suffixes removed.
 This class is not specific to cross validation applications and is meant
 to also serve as a starting point for other applications in which Netica
 functions must be used in Python.
\end_layout

\begin_layout Standard
The easiest type is a pointer to an object returned by another Netica function.
 In this case, a Python variable represents the pointer--just a memory address--
so no conversion is necessary.
 For single Python floats and ints, the conversions are 
\family typewriter
ct.c_double(cval)
\family default
 and 
\family typewriter
ct.c_int(cval)
\family default
, respectively, where 
\family typewriter
cval
\family default
 is the Python variable.
 
\end_layout

\begin_layout Standard

\change_deleted -74556787 1396027792
The most straightforward retrieval of of information from a Netica function
 is when the returned value is a pointer to a Netica object (for example,
 the Netica environment, a node, or a net).
 These values can be assigned to variables in Python and then passed to
 Netica functions without any alteration, as illustrated above.
 
\change_unchanged

\end_layout

\begin_layout Standard
Some Netica functions return a double value but also write another result
 to memory at a location indicated by a pointer passed to the function.
 An example is 
\family typewriter
GetNodeExpectedValue_bn
\family default
.
 The structure of this function in C is
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

double GetNodeExpectedValue_bn (node_bn* node, 
\end_layout

\begin_layout Plain Layout

	double* std_dev, double* x3, double* x4)
\end_layout

\end_inset


\family default
where the returned value is the expected value (double precision) of the
 node identified by 
\family typewriter
node_bn*
\family default
, the standard deviation is written to the memory location identified by
 the pointer 
\family typewriter
double* std_dev
\family default
, and 
\begin_inset Formula $\mathtt{x3}$
\end_inset

 and 
\begin_inset Formula $\mathtt{x4}$
\end_inset

 are NULL pointers reserved for future implementation.
 To collect the main returned value of the function, we must set 
\begin_inset Formula $\mathtt{restype}$
\end_inset

 of the function--often accomplished through making an alias temporary function-
-and accepting the value as normally with a function.
 To make use of the returned second value in Python--the value written to
 a memory location identified by a pointer--we must pass a 
\begin_inset Formula $\mathtt{double}$
\end_inset

 variable by reference (in other words, a pointer to the 
\begin_inset Formula $\mathtt{double}$
\end_inset

).
 The Python wrapper for 
\family typewriter
GetNodeExpectedValue_bn
\family default
 illustrates this process 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def GetNodeExpectedValue(self,cnode): 
\end_layout

\begin_layout Plain Layout

	std_dev = ct.c_double() 
\end_layout

\begin_layout Plain Layout

	tmpNeticaFun = self.n.GetNodeExpectedValue_bn
\end_layout

\begin_layout Plain Layout

	tmpNeticaFun.restype=ct.c_double 
\end_layout

\begin_layout Plain Layout

	expected_val = tmpNeticaFun(cnode,ct.byref(std_dev), 
\end_layout

\begin_layout Plain Layout

                                None,None) 
\end_layout

\begin_layout Plain Layout

	self.chkerr() 
\end_layout

\begin_layout Plain Layout

	return expected_val, std_dev.value
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some Netica functions return either a character array or a numerical array.
 In both cases, the C code in Netica returns a pointer to the data.
 The Python code must, then, read a specified amount of data from that pointer
 location.
 Unlike pure Python, it is possible to read off the end of the information
 starting at the pointer location, so we must also specify the number of
 values to read from the memory location.
 Helper functions in 
\begin_inset Formula $\mathtt{cthelper.py}$
\end_inset

 read the character pointers, and single and double precision pointers.
 An example of this being used in CVNetica is in the 
\begin_inset Formula $\mathtt{ReadNodeInfo}$
\end_inset

 method of the 
\begin_inset Formula $\mathtt{pyneticaTools}$
\end_inset

 class.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Example Applications
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The CVNetica code was applied to two different applications to evaluate
 predictive performance and guide the appropriate level of complexity for
 BN design.
 The two applications are a data-driven application with ocean waves (NATHANIEL
 -- you can explain better) and a model emulation application using a BN
 to make predictions trained on results of a groundwater flow model.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data driven ocean waves
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Weather forecasting and modeling has achieved sufficiently high accuracy
 that it is possible to replace observations with models if models are 
\change_deleted -74556787 1396027815
intialized
\change_inserted -74556787 1396027815
initialized
\change_unchanged
 well and have good boundary 
\change_deleted -74556787 1396027818
condtion
\change_inserted -74556787 1396027818
condition
\change_unchanged
 data.
 However, weather forecasts are not routinely available for periods extending
 more than a few days ahead, and they become less accurate.
 We would like to allow the climatological prior information to inform predictio
ns when observations or forecasts are not 
\change_deleted -74556787 1396027821
availabble
\change_inserted -74556787 1396027821
available
\change_unchanged
 or are uncertain.
 As an 
\change_deleted -74556787 1396027825
exampe
\change_inserted -74556787 1396027825
example
\change_unchanged
, we would like to predict wave height just offshore of the coast where
 there are not persistent observations.
 This could be done with laborious Monte Carlo simulations using models
 and previous climatology for model initialization and boundary-condition
 forcing.
 Or, we could use extant model output or observations to learn both the
 sensitivity of a specific prediction to changes in boundary 
\change_deleted -74556787 1396027829
condtions
\change_inserted -74556787 1396027829
conditions
\change_unchanged
 and include uncertainty in this sensitivity (the joint correlation) as
 well as uncertainty in the boundary conditions.
 This approach has been implemented before using 
\change_inserted -74556787 1396028443
B
\change_deleted -74556787 1396028443
b
\change_unchanged
ayesian networks (2 plant papers, who else), but the fidelity of the of
 the resulting BN models was not examined in detail, other than to note
 that to maximize the consistency of the BN predictions with new observations,
 the BN inputs should include input parameter-value or data uncertainties.
 Were these BN models over-fit to the data?
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/bermPy_v3.svg
	scale 40

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:BNocean"

\end_inset

BN for the wave height prediction model.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, we explore the level of overfitting with a simplified ocean-wave predictio
n model based on a BN.
 The specific BN
\change_inserted -74556787 1396028356
, illustrated in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:BNocean"

\end_inset

,
\change_unchanged
 has been used to drive subsequent predictions of morphologic evolution
 of a man-made sand berm constructed near the Chandeleur Islands (Plant
 2014 paper).
 Here, we simplify the original model, which included information from two
 wave buoys, one tide gage, and Monte Carlo simulation of a wave-runup model
 (Stockdon 2006 paper).
 The first two columns of network nodes (Figure) correspond to observations
 from an offshore buoy (NOAA 42040) collected from 1996 to 2011.
 The variables are wind speed and direction and wave height, period, and
 direction.
 The third column has just one variable, wave height, that was observed
 at a nearshore buoy between 2000 and 2008.
 The nearshore buoy was subsequently lost.
 The BN describing the prior 
\change_deleted -74556787 1396028362
probabbiliies
\change_inserted -74556787 1396028362
probabilities
\change_unchanged
 of each variable and the conditional probabilities between variables was
 designed to resolve boundary 
\change_deleted -74556787 1396028366
condtions
\change_inserted -74556787 1396028366
conditions
\change_unchanged
 at the offshore location and the prediction at the nearshore location accuratel
y enough to support the morphologic evolution application.
 While this BN had very good hindcast skill (about 0.8), it is not clear
 that it has equally good forecast skill and whether fewer probability bins
 could be retained to give a skillful prediction with optimal numerical
 efficiency.
 
\end_layout

\begin_layout Standard
Our calibration/validation skill analysis was applied to this net by varying
 the number of bins in all variables except for the wave heights.
 We chose to resolve these variables consistently with the original model
 to ensure that probability predictions spanned a wide range conditions,
 rather than focusing on the most probable but extremely low wave-height
 range that was most common (i.e., 1-3 m).
 The variable bin number ranged from 2 to 10 for the remaining variables.
 The calibration (i.e., hindcast) skill increased for all choices of bin numbers
\change_inserted -74556787 1396028397
 (figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CVocean"

\end_inset

)
\change_unchanged
.
 However, the validation skill, averaged over 5 folds, reached its peak
 value at 4 bins and then decreased dramatically after 6 bins.
 The optimal bin 
\change_deleted -74556787 1396028404
resolutioni
\change_inserted -74556787 1396028404
resolution
\change_unchanged
 likely varied for each variable type (wind speed, wind and wave directions,
 wave period) and this may explain the flattening of the validation curve
 between 4 and 6 bins, as it is possible that increasing bin resolution
 was advantageous, adding necessary resolution, for some variables but a
 disadvantage for others.
 The rapid decline after 6 bins suggests that none of the variables needed
 to be better resolved past this point.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/berm_mean_skillMean.pdf
	scale 50

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:CVocean"

\end_inset

Calibration (descriptive) and Validation (predictive) skill values for various
 arrangements of bins on the wave prediction BN.
 For sets identified by a single number, that number of bins was used to
 discretize all nodes.
 The color shading indicates the 95% credible interval based on adding and
 subtracting 
\begin_inset Formula $2\sigma$
\end_inset

 to and from the median value of each metric over the 10 folds evaluated.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Model emulation source of groundwater to wells
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the Great Lakes Region of the United States, the interactions between
 groundwater and surface water are of important management interest.
 Specifically, as extraction wells are installed, the baseflow in streams
 can be reduced with important ramifications on fish habitat and associated
 societal concern 
\begin_inset CommandInset citation
LatexCommand citep
key "Ruswick2010"

\end_inset


\change_inserted -74556787 1396028519

\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted -74556787 1396028537
MIKE add refs to Howard Reeves' new GW article and Stan/Barlow cirulcar
\change_unchanged

\end_layout

\end_inset


\change_unchanged
.
 An efficient method to determine the source of water to wells has the potential
 to improve management in the region by quickly screening proposed wells.
 If the source of water emanating from surface water (either through diversion
 or depletion) reaches a management threshold, then further management actions
 may be triggered.
 Using a numerical groundwater model, managers could conceivably explicitly
 model each proposed well location but run times and technical background
 may be prohibitive for that task.
 A more efficient option is model emulation as performed on a groundwater
 model by 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

.
\end_layout

\begin_layout Standard
In this case, using MODFLOW-2005 
\begin_inset CommandInset citation
LatexCommand citep
key "mf05"

\end_inset

 (REFERENCE USG!!!), extraction wells were simulated on multiple staggered
 grids at sufficient distances that they would not interact in individual
 model runs.
 A base case was also simulated without extraction wells and, through superposit
ion, the sources of water to the wells was evaluated and mappable characteristic
s of each well location were used to create the BN in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

.
\end_layout

\begin_layout Standard
An important question--similar to that evaluated by 
\begin_inset CommandInset citation
LatexCommand citet
key "FienenBNWRR"

\end_inset

--is what level of complexity provides the best tradeoff between descriptive
 and predictive power of the BN.
 Using CVNetica, it was possible to quickly evaluate 
\begin_inset Formula $k$
\end_inset

--fold cross validation for a variety of combinations of bins in the node
 arrangement depicted in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:exampleBN"

\end_inset

.
 For the most important response variable--SW_SRC which is surface water
 source--Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CVglacial"

\end_inset

 depicts the change in both calibration and validation performance for 10-fold
 cross validation performed over an increasingly complex set of bin configuratio
n.
 While increasing complexity monotonically improves calibration (description)
 over the training set, the skill improves at first for validation (prediction)
 but then degrades dramatically after three or four bins on the input nodes.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CVglacial"

\end_inset

, sets identified by a single value indicate the number of bins used to
 discretize each node.
 When a second number is present, the first number indicates bins used for
 the input nodes while the second indicates bins used for the output nodes.
 Little degradation and possibly a slight improvement in validation skill
 is seen with increasing output bins for a given complexity of input.
 This highlights that the main fitting of the BN takes place with respect
 to input and output complexity is more a matter of convenience than a source
 of real BN complexity.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename figures/glacial_CV.pdf
	scale 50

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:CVglacial"

\end_inset

Calibration (descriptive) and Validation (predictive) skill values for various
 arrangements of bins on the glacial aquifer BN.
 For sets identified by a single number, that number of bins was used to
 discretize all nodes.
 For sets identified by two numbers separated by an underscore, the first
 and second numbers indicate the number of bins the input and output nodes,
 respectively, were discretized.
 The color shading indicates the 95% credible interval based on adding and
 subtracting 
\begin_inset Formula $2\sigma$
\end_inset

 to and from the median value of each metric over the 10 folds evaluated.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Discussion and Conclusions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{linenumbers}
\end_layout

\end_inset


\change_inserted -74556787 1396029561

\end_layout

\begin_layout Standard

\change_inserted -74556787 1396029730
CVNetica is an open-source Python module using the 
\family typewriter
ctypes
\family default
 module to drive APIs for the Netica BN software.
 The purpose is to implement cross-validation techniques for evaluating
 descriptive (calibration) versus predictive (validation) performance of
 BNs.
 
\change_unchanged

\end_layout

\begin_layout Itemize

\change_deleted -74556787 1396029738
how does the code work?
\end_layout

\begin_layout Itemize

\change_deleted -74556787 1396029738
what did we learn in data-driven areas?
\end_layout

\begin_layout Itemize

\change_deleted -74556787 1396029738
what are ramifications for model emulation design?
\end_layout

\begin_layout Itemize

\change_deleted -74556787 1396029738
Comment on other skill metrics?
\end_layout

\begin_layout Itemize

\change_deleted -74556787 1396029738
is CV really all that or a waste of time?
\end_layout

\begin_layout Standard
We show that CV provides an objective method for determining when a BN is
 being overfit to the data.
 And, it appears that overfitting is likely when the BN is designed to resolve
 physical processes, either observed or modeled.
 In the cases presented here, the BN design was guided by distribution of
 the priors of each variable as well as by the intended application of the
 BN predictions.
 For instance, in the ocean wave example, the intended application focused
 on res
\change_deleted -74556787 1396029797
l
\change_unchanged
olving large storm events that were likely to cause erosion.
 This guided a a choice of fairly high resolution of the input data a the
 offshore buoy.
 While 
\change_deleted -74556787 1396029779
phyisically
\change_inserted -74556787 1396029779
physically
\change_unchanged
 consistent, a price needed to be paid for the over-res
\change_deleted -74556787 1396029813
l
\change_unchanged
o
\change_inserted -74556787 1396029815
l
\change_unchanged
ved output in order to achi
\change_inserted -74556787 1396029819
e
\change_unchanged
ve true predictive skill.
 That price was to greatly reduce the resolution of the input var
\change_deleted -74556787 1396029825
a
\change_unchanged
i
\change_inserted -74556787 1396029826
a
\change_unchanged
bles from as many as 12 bins to no more than 6 bins.
 While a price is paid in terms of input detail, there is a numerical benefit
 to reducing the bin resolution.
 For instance, the original ocean wave BN maintained over a million possible
 combinations of inputs and outputs scenarios within its conditional 
\change_deleted -74556787 1396029770
probabililty
\change_inserted -74556787 1396029770
probability
\change_unchanged
 tables while the optimal 4-bin BN maintained 44 times fewer scenarios,
 reduced memory requirements, and had increased training and prediction
 speeds.
 For insta
\change_inserted -74556787 1396029854
n
\change_unchanged
ce, the CV processing took 25 minutes for the 4-bin net compared to over
 8 hours for the original net (a f
\change_inserted -74556787 1396029862
a
\change_deleted -74556787 1396029861
o
\change_unchanged
ctor of 20 difference).
 
\change_deleted -74556787 1396029869
Cool!
\change_inserted -74556787 1396029869

\end_layout

\begin_layout Standard

\change_inserted -74556787 1396030595
In the model emulation case, fewer input bins were supported while maintaining
 good predictive power.
 Four input bins resulted in good performance while a degradation of predictive
 skill started with five input bins.
 Predictive skill was relatively consistent with respect to output bins
 between 5 and 10 for a given set of input bins.
 This allows a resource manager to convey outcomes with some flexibility
 beyond the level of complexity supported by the data on the input side.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{linenumbers}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
This work was funded by (ASIS and GLAS others depending on which example
 application we use) and the USGS Coastal and Marine Geology Program.
 We are deeply grateful to Steven Mascaro for his initial PyNetica.py code
 which he kindly shared as a starting point for this work.
\end_layout

\begin_layout Section
Disclaimer
\end_layout

\begin_layout Standard
Any use of trade, product, or firm names is for descriptive purposes only
 and does not imply endorsement by the U.S.
 Government.
 
\end_layout

\begin_layout Section
References
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "GW"
options "elsarticle-num-names"

\end_inset


\end_layout

\end_body
\end_document
